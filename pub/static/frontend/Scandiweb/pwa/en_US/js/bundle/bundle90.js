require.config({"config": {
        "jsbuild":{"jquery/fileUploader/jquery.fileupload.js":"/*\n * jQuery File Upload Plugin 5.16.4\n * https://github.com/blueimp/jQuery-File-Upload\n *\n * Copyright 2010, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * http://www.opensource.org/licenses/MIT\n */\n\n/*jslint nomen: true, unparam: true, regexp: true */\n/*global define, window, document, Blob, FormData, location */\n\n(function (factory) {\n    'use strict';\n    if (typeof define === 'function' && define.amd) {\n        // Register as an anonymous AMD module:\n        define([\n            'jquery',\n            'jquery-ui-modules/widget',\n            'jquery/fileUploader/jquery.iframe-transport'\n        ], factory);\n    } else {\n        // Browser globals:\n        factory(window.jQuery);\n    }\n}(function ($) {\n    'use strict';\n\n    // The FileReader API is not actually used, but works as feature detection,\n    // as e.g. Safari supports XHR file uploads via the FormData API,\n    // but not non-multipart XHR file uploads:\n    $.support.xhrFileUpload = !!(window.XMLHttpRequestUpload && window.FileReader);\n    $.support.xhrFormDataFileUpload = !!window.FormData;\n\n    // The fileupload widget listens for change events on file input fields defined\n    // via fileInput setting and paste or drop events of the given dropZone.\n    // In addition to the default jQuery Widget methods, the fileupload widget\n    // exposes the \"add\" and \"send\" methods, to add or directly send files using\n    // the fileupload API.\n    // By default, files added via file input selection, paste, drag & drop or\n    // \"add\" method are uploaded immediately, but it is possible to override\n    // the \"add\" callback option to queue file uploads.\n    $.widget('blueimp.fileupload', {\n\n        options: {\n            // The namespace used for event handler binding on the dropZone and\n            // fileInput collections.\n            // If not set, the name of the widget (\"fileupload\") is used.\n            namespace: undefined,\n            // The drop target collection, by the default the complete document.\n            // Set to null or an empty collection to disable drag & drop support:\n            dropZone: $(document),\n            // The file input field collection, that is listened for change events.\n            // If undefined, it is set to the file input fields inside\n            // of the widget element on plugin initialization.\n            // Set to null or an empty collection to disable the change listener.\n            fileInput: undefined,\n            // By default, the file input field is replaced with a clone after\n            // each input field change event. This is required for iframe transport\n            // queues and allows change events to be fired for the same file\n            // selection, but can be disabled by setting the following option to false:\n            replaceFileInput: true,\n            // The parameter name for the file form data (the request argument name).\n            // If undefined or empty, the name property of the file input field is\n            // used, or \"files[]\" if the file input name property is also empty,\n            // can be a string or an array of strings:\n            paramName: undefined,\n            // By default, each file of a selection is uploaded using an individual\n            // request for XHR type uploads. Set to false to upload file\n            // selections in one request each:\n            singleFileUploads: true,\n            // To limit the number of files uploaded with one XHR request,\n            // set the following option to an integer greater than 0:\n            limitMultiFileUploads: undefined,\n            // Set the following option to true to issue all file upload requests\n            // in a sequential order:\n            sequentialUploads: false,\n            // To limit the number of concurrent uploads,\n            // set the following option to an integer greater than 0:\n            limitConcurrentUploads: undefined,\n            // Set the following option to true to force iframe transport uploads:\n            forceIframeTransport: false,\n            // Set the following option to the location of a redirect url on the\n            // origin server, for cross-domain iframe transport uploads:\n            redirect: undefined,\n            // The parameter name for the redirect url, sent as part of the form\n            // data and set to 'redirect' if this option is empty:\n            redirectParamName: undefined,\n            // Set the following option to the location of a postMessage window,\n            // to enable postMessage transport uploads:\n            postMessage: undefined,\n            // By default, XHR file uploads are sent as multipart/form-data.\n            // The iframe transport is always using multipart/form-data.\n            // Set to false to enable non-multipart XHR uploads:\n            multipart: true,\n            // To upload large files in smaller chunks, set the following option\n            // to a preferred maximum chunk size. If set to 0, null or undefined,\n            // or the browser does not support the required Blob API, files will\n            // be uploaded as a whole.\n            maxChunkSize: undefined,\n            // When a non-multipart upload or a chunked multipart upload has been\n            // aborted, this option can be used to resume the upload by setting\n            // it to the size of the already uploaded bytes. This option is most\n            // useful when modifying the options object inside of the \"add\" or\n            // \"send\" callbacks, as the options are cloned for each file upload.\n            uploadedBytes: undefined,\n            // By default, failed (abort or error) file uploads are removed from the\n            // global progress calculation. Set the following option to false to\n            // prevent recalculating the global progress data:\n            recalculateProgress: true,\n            // Interval in milliseconds to calculate and trigger progress events:\n            progressInterval: 100,\n            // Interval in milliseconds to calculate progress bitrate:\n            bitrateInterval: 500,\n\n            // Additional form data to be sent along with the file uploads can be set\n            // using this option, which accepts an array of objects with name and\n            // value properties, a function returning such an array, a FormData\n            // object (for XHR file uploads), or a simple object.\n            // The form of the first fileInput is given as parameter to the function:\n            formData: function (form) {\n                return form.serializeArray();\n            },\n\n            // The add callback is invoked as soon as files are added to the fileupload\n            // widget (via file input selection, drag & drop, paste or add API call).\n            // If the singleFileUploads option is enabled, this callback will be\n            // called once for each file in the selection for XHR file uplaods, else\n            // once for each file selection.\n            // The upload starts when the submit method is invoked on the data parameter.\n            // The data object contains a files property holding the added files\n            // and allows to override plugin options as well as define ajax settings.\n            // Listeners for this callback can also be bound the following way:\n            // .bind('fileuploadadd', func);\n            // data.submit() returns a Promise object and allows to attach additional\n            // handlers using jQuery's Deferred callbacks:\n            // data.submit().done(func).fail(func).always(func);\n            add: function (e, data) {\n                data.submit();\n            },\n\n            // Other callbacks:\n            // Callback for the submit event of each file upload:\n            // submit: function (e, data) {}, // .bind('fileuploadsubmit', func);\n            // Callback for the start of each file upload request:\n            // send: function (e, data) {}, // .bind('fileuploadsend', func);\n            // Callback for successful uploads:\n            // done: function (e, data) {}, // .bind('fileuploaddone', func);\n            // Callback for failed (abort or error) uploads:\n            // fail: function (e, data) {}, // .bind('fileuploadfail', func);\n            // Callback for completed (success, abort or error) requests:\n            // always: function (e, data) {}, // .bind('fileuploadalways', func);\n            // Callback for upload progress events:\n            // progress: function (e, data) {}, // .bind('fileuploadprogress', func);\n            // Callback for global upload progress events:\n            // progressall: function (e, data) {}, // .bind('fileuploadprogressall', func);\n            // Callback for uploads start, equivalent to the global ajaxStart event:\n            // start: function (e) {}, // .bind('fileuploadstart', func);\n            // Callback for uploads stop, equivalent to the global ajaxStop event:\n            // stop: function (e) {}, // .bind('fileuploadstop', func);\n            // Callback for change events of the fileInput collection:\n            // change: function (e, data) {}, // .bind('fileuploadchange', func);\n            // Callback for paste events to the dropZone collection:\n            // paste: function (e, data) {}, // .bind('fileuploadpaste', func);\n            // Callback for drop events of the dropZone collection:\n            // drop: function (e, data) {}, // .bind('fileuploaddrop', func);\n            // Callback for dragover events of the dropZone collection:\n            // dragover: function (e) {}, // .bind('fileuploaddragover', func);\n\n            // The plugin options are used as settings object for the ajax calls.\n            // The following are jQuery ajax settings required for the file uploads:\n            processData: false,\n            contentType: false,\n            cache: false\n        },\n\n        // A list of options that require a refresh after assigning a new value:\n        _refreshOptionsList: [\n            'namespace',\n            'dropZone',\n            'fileInput',\n            'multipart',\n            'forceIframeTransport'\n        ],\n\n        _BitrateTimer: function () {\n            this.timestamp = +(new Date());\n            this.loaded = 0;\n            this.bitrate = 0;\n            this.getBitrate = function (now, loaded, interval) {\n                var timeDiff = now - this.timestamp;\n                if (!this.bitrate || !interval || timeDiff > interval) {\n                    this.bitrate = (loaded - this.loaded) * (1000 / timeDiff) * 8;\n                    this.loaded = loaded;\n                    this.timestamp = now;\n                }\n                return this.bitrate;\n            };\n        },\n\n        _isXHRUpload: function (options) {\n            return !options.forceIframeTransport &&\n                ((!options.multipart && $.support.xhrFileUpload) ||\n                $.support.xhrFormDataFileUpload);\n        },\n\n        _getFormData: function (options) {\n            var formData;\n            if (typeof options.formData === 'function') {\n                return options.formData(options.form);\n            }\n\t\t\tif ($.isArray(options.formData)) {\n                return options.formData;\n            }\n\t\t\tif (options.formData) {\n                formData = [];\n                $.each(options.formData, function (name, value) {\n                    formData.push({name: name, value: value});\n                });\n                return formData;\n            }\n            return [];\n        },\n\n        _getTotal: function (files) {\n            var total = 0;\n            $.each(files, function (index, file) {\n                total += file.size || 1;\n            });\n            return total;\n        },\n\n        _onProgress: function (e, data) {\n            if (e.lengthComputable) {\n                var now = +(new Date()),\n                    total,\n                    loaded;\n                if (data._time && data.progressInterval &&\n                        (now - data._time < data.progressInterval) &&\n                        e.loaded !== e.total) {\n                    return;\n                }\n                data._time = now;\n                total = data.total || this._getTotal(data.files);\n                loaded = parseInt(\n                    e.loaded / e.total * (data.chunkSize || total),\n                    10\n                ) + (data.uploadedBytes || 0);\n                this._loaded += loaded - (data.loaded || data.uploadedBytes || 0);\n                data.lengthComputable = true;\n                data.loaded = loaded;\n                data.total = total;\n                data.bitrate = data._bitrateTimer.getBitrate(\n                    now,\n                    loaded,\n                    data.bitrateInterval\n                );\n                // Trigger a custom progress event with a total data property set\n                // to the file size(s) of the current upload and a loaded data\n                // property calculated accordingly:\n                this._trigger('progress', e, data);\n                // Trigger a global progress event for all current file uploads,\n                // including ajax calls queued for sequential file uploads:\n                this._trigger('progressall', e, {\n                    lengthComputable: true,\n                    loaded: this._loaded,\n                    total: this._total,\n                    bitrate: this._bitrateTimer.getBitrate(\n                        now,\n                        this._loaded,\n                        data.bitrateInterval\n                    )\n                });\n            }\n        },\n\n        _initProgressListener: function (options) {\n            var that = this,\n                xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();\n            // Accesss to the native XHR object is required to add event listeners\n            // for the upload progress event:\n            if (xhr.upload) {\n                $(xhr.upload).bind('progress', function (e) {\n                    var oe = e.originalEvent;\n                    // Make sure the progress event properties get copied over:\n                    e.lengthComputable = oe.lengthComputable;\n                    e.loaded = oe.loaded;\n                    e.total = oe.total;\n                    that._onProgress(e, options);\n                });\n                options.xhr = function () {\n                    return xhr;\n                };\n            }\n        },\n\n        _initXHRData: function (options) {\n            var formData,\n                file = options.files[0],\n                // Ignore non-multipart setting if not supported:\n                multipart = options.multipart || !$.support.xhrFileUpload,\n                paramName = options.paramName[0];\n            if (!multipart || options.blob) {\n                // For non-multipart uploads and chunked uploads,\n                // file meta data is not part of the request body,\n                // so we transmit this data as part of the HTTP headers.\n                // For cross domain requests, these headers must be allowed\n                // via Access-Control-Allow-Headers or removed using\n                // the beforeSend callback:\n                options.headers = $.extend(options.headers, {\n                    'X-File-Name': file.name,\n                    'X-File-Type': file.type,\n                    'X-File-Size': file.size\n                });\n                if (!options.blob) {\n                    // Non-chunked non-multipart upload:\n                    options.contentType = file.type;\n                    options.data = file;\n                } else if (!multipart) {\n                    // Chunked non-multipart upload:\n                    options.contentType = 'application/octet-stream';\n                    options.data = options.blob;\n                }\n            }\n            if (multipart && $.support.xhrFormDataFileUpload) {\n                if (options.postMessage) {\n                    // window.postMessage does not allow sending FormData\n                    // objects, so we just add the File/Blob objects to\n                    // the formData array and let the postMessage window\n                    // create the FormData object out of this array:\n                    formData = this._getFormData(options);\n                    if (options.blob) {\n                        formData.push({\n                            name: paramName,\n                            value: options.blob\n                        });\n                    } else {\n                        $.each(options.files, function (index, file) {\n                            formData.push({\n                                name: options.paramName[index] || paramName,\n                                value: file\n                            });\n                        });\n                    }\n                } else {\n                    if (options.formData instanceof FormData) {\n                        formData = options.formData;\n                    } else {\n                        formData = new FormData();\n                        $.each(this._getFormData(options), function (index, field) {\n                            formData.append(field.name, field.value);\n                        });\n                    }\n                    if (options.blob) {\n                        formData.append(paramName, options.blob, file.name);\n                    } else {\n                        $.each(options.files, function (index, file) {\n                            // File objects are also Blob instances.\n                            // This check allows the tests to run with\n                            // dummy objects:\n                            if (file instanceof Blob) {\n                                formData.append(\n                                    options.paramName[index] || paramName,\n                                    file,\n                                    file.name\n                                );\n                            }\n                        });\n                    }\n                }\n                options.data = formData;\n            }\n            // Blob reference is not needed anymore, free memory:\n            options.blob = null;\n        },\n\n        _initIframeSettings: function (options) {\n            // Setting the dataType to iframe enables the iframe transport:\n            options.dataType = 'iframe ' + (options.dataType || '');\n            // The iframe transport accepts a serialized array as form data:\n            options.formData = this._getFormData(options);\n            // Add redirect url to form data on cross-domain uploads:\n            if (options.redirect && $('<a></a>').prop('href', options.url)\n                    .prop('host') !== location.host) {\n                options.formData.push({\n                    name: options.redirectParamName || 'redirect',\n                    value: options.redirect\n                });\n            }\n        },\n\n        _initDataSettings: function (options) {\n            if (this._isXHRUpload(options)) {\n                if (!this._chunkedUpload(options, true)) {\n                    if (!options.data) {\n                        this._initXHRData(options);\n                    }\n                    this._initProgressListener(options);\n                }\n                if (options.postMessage) {\n                    // Setting the dataType to postmessage enables the\n                    // postMessage transport:\n                    options.dataType = 'postmessage ' + (options.dataType || '');\n                }\n            } else {\n                this._initIframeSettings(options, 'iframe');\n            }\n        },\n\n        _getParamName: function (options) {\n            var fileInput = $(options.fileInput),\n                paramName = options.paramName;\n            if (!paramName) {\n                paramName = [];\n                fileInput.each(function () {\n                    var input = $(this),\n                        name = input.prop('name') || 'files[]',\n                        i = (input.prop('files') || [1]).length;\n                    while (i) {\n                        paramName.push(name);\n                        i -= 1;\n                    }\n                });\n                if (!paramName.length) {\n                    paramName = [fileInput.prop('name') || 'files[]'];\n                }\n            } else if (!$.isArray(paramName)) {\n                paramName = [paramName];\n            }\n            return paramName;\n        },\n\n        _initFormSettings: function (options) {\n            // Retrieve missing options from the input field and the\n            // associated form, if available:\n            if (!options.form || !options.form.length) {\n                options.form = $(options.fileInput.prop('form'));\n            }\n            options.paramName = this._getParamName(options);\n            if (!options.url) {\n                options.url = options.form.prop('action') || location.href;\n            }\n            // The HTTP request method must be \"POST\" or \"PUT\":\n            options.type = (options.type || options.form.prop('method') || '')\n                .toUpperCase();\n            if (options.type !== 'POST' && options.type !== 'PUT') {\n                options.type = 'POST';\n            }\n            if (!options.formAcceptCharset) {\n                options.formAcceptCharset = options.form.attr('accept-charset');\n            }\n        },\n\n        _getAJAXSettings: function (data) {\n            var options = $.extend({}, this.options, data);\n            this._initFormSettings(options);\n            this._initDataSettings(options);\n            return options;\n        },\n\n        // Maps jqXHR callbacks to the equivalent\n        // methods of the given Promise object:\n        _enhancePromise: function (promise) {\n            promise.success = promise.done;\n            promise.error = promise.fail;\n            promise.complete = promise.always;\n            return promise;\n        },\n\n        // Creates and returns a Promise object enhanced with\n        // the jqXHR methods abort, success, error and complete:\n        _getXHRPromise: function (resolveOrReject, context, args) {\n            var dfd = $.Deferred(),\n                promise = dfd.promise();\n            context = context || this.options.context || promise;\n            if (resolveOrReject === true) {\n                dfd.resolveWith(context, args);\n            } else if (resolveOrReject === false) {\n                dfd.rejectWith(context, args);\n            }\n            promise.abort = dfd.promise;\n            return this._enhancePromise(promise);\n        },\n\n        // Uploads a file in multiple, sequential requests\n        // by splitting the file up in multiple blob chunks.\n        // If the second parameter is true, only tests if the file\n        // should be uploaded in chunks, but does not invoke any\n        // upload requests:\n        _chunkedUpload: function (options, testOnly) {\n            var that = this,\n                file = options.files[0],\n                fs = file.size,\n                ub = options.uploadedBytes = options.uploadedBytes || 0,\n                mcs = options.maxChunkSize || fs,\n                // Use the Blob methods with the slice implementation\n                // according to the W3C Blob API specification:\n                slice = file.webkitSlice || file.mozSlice || file.slice,\n                upload,\n                n,\n                jqXHR,\n                pipe;\n            if (!(this._isXHRUpload(options) && slice && (ub || mcs < fs)) ||\n                    options.data) {\n                return false;\n            }\n            if (testOnly) {\n                return true;\n            }\n            if (ub >= fs) {\n                file.error = 'uploadedBytes';\n                return this._getXHRPromise(\n                    false,\n                    options.context,\n                    [null, 'error', file.error]\n                );\n            }\n            // n is the number of blobs to upload,\n            // calculated via filesize, uploaded bytes and max chunk size:\n            n = Math.ceil((fs - ub) / mcs);\n            // The chunk upload method accepting the chunk number as parameter:\n            upload = function (i) {\n                if (!i) {\n                    return that._getXHRPromise(true, options.context);\n                }\n                // Upload the blobs in sequential order:\n                return upload(i -= 1).pipe(function () {\n                    // Clone the options object for each chunk upload:\n                    var o = $.extend({}, options);\n                    o.blob = slice.call(\n                        file,\n                        ub + i * mcs,\n                        ub + (i + 1) * mcs\n                    );\n                    // Expose the chunk index:\n                    o.chunkIndex = i;\n                    // Expose the number of chunks:\n                    o.chunksNumber = n;\n                    // Store the current chunk size, as the blob itself\n                    // will be dereferenced after data processing:\n                    o.chunkSize = o.blob.size;\n                    // Process the upload data (the blob and potential form data):\n                    that._initXHRData(o);\n                    // Add progress listeners for this chunk upload:\n                    that._initProgressListener(o);\n                    jqXHR = ($.ajax(o) || that._getXHRPromise(false, o.context))\n                        .done(function () {\n                            // Create a progress event if upload is done and\n                            // no progress event has been invoked for this chunk:\n                            if (!o.loaded) {\n                                that._onProgress($.Event('progress', {\n                                    lengthComputable: true,\n                                    loaded: o.chunkSize,\n                                    total: o.chunkSize\n                                }), o);\n                            }\n                            options.uploadedBytes = o.uploadedBytes +=\n                                o.chunkSize;\n                        });\n                    return jqXHR;\n                });\n            };\n            // Return the piped Promise object, enhanced with an abort method,\n            // which is delegated to the jqXHR object of the current upload,\n            // and jqXHR callbacks mapped to the equivalent Promise methods:\n            pipe = upload(n);\n            pipe.abort = function () {\n                return jqXHR.abort();\n            };\n            return this._enhancePromise(pipe);\n        },\n\n        _beforeSend: function (e, data) {\n            if (this._active === 0) {\n                // the start callback is triggered when an upload starts\n                // and no other uploads are currently running,\n                // equivalent to the global ajaxStart event:\n                this._trigger('start');\n                // Set timer for global bitrate progress calculation:\n                this._bitrateTimer = new this._BitrateTimer();\n            }\n            this._active += 1;\n            // Initialize the global progress values:\n            this._loaded += data.uploadedBytes || 0;\n            this._total += this._getTotal(data.files);\n        },\n\n        _onDone: function (result, textStatus, jqXHR, options) {\n            if (!this._isXHRUpload(options)) {\n                // Create a progress event for each iframe load:\n                this._onProgress($.Event('progress', {\n                    lengthComputable: true,\n                    loaded: 1,\n                    total: 1\n                }), options);\n            }\n            options.result = result;\n            options.textStatus = textStatus;\n            options.jqXHR = jqXHR;\n            this._trigger('done', null, options);\n        },\n\n        _onFail: function (jqXHR, textStatus, errorThrown, options) {\n            options.jqXHR = jqXHR;\n            options.textStatus = textStatus;\n            options.errorThrown = errorThrown;\n            this._trigger('fail', null, options);\n            if (options.recalculateProgress) {\n                // Remove the failed (error or abort) file upload from\n                // the global progress calculation:\n                this._loaded -= options.loaded || options.uploadedBytes || 0;\n                this._total -= options.total || this._getTotal(options.files);\n            }\n        },\n\n        _onAlways: function (jqXHRorResult, textStatus, jqXHRorError, options) {\n            this._active -= 1;\n            options.textStatus = textStatus;\n            if (jqXHRorError && jqXHRorError.always) {\n                options.jqXHR = jqXHRorError;\n                options.result = jqXHRorResult;\n            } else {\n                options.jqXHR = jqXHRorResult;\n                options.errorThrown = jqXHRorError;\n            }\n            this._trigger('always', null, options);\n            if (this._active === 0) {\n                // The stop callback is triggered when all uploads have\n                // been completed, equivalent to the global ajaxStop event:\n                this._trigger('stop');\n                // Reset the global progress values:\n                this._loaded = this._total = 0;\n                this._bitrateTimer = null;\n            }\n        },\n\n        _onSend: function (e, data) {\n            var that = this,\n                jqXHR,\n                slot,\n                pipe,\n                options = that._getAJAXSettings(data),\n                send = function (resolve, args) {\n                    that._sending += 1;\n                    // Set timer for bitrate progress calculation:\n                    options._bitrateTimer = new that._BitrateTimer();\n                    jqXHR = jqXHR || (\n                        (resolve !== false &&\n                        that._trigger('send', e, options) !== false &&\n                        (that._chunkedUpload(options) || $.ajax(options))) ||\n                        that._getXHRPromise(false, options.context, args)\n                    ).done(function (result, textStatus, jqXHR) {\n                        that._onDone(result, textStatus, jqXHR, options);\n                    }).fail(function (jqXHR, textStatus, errorThrown) {\n                        that._onFail(jqXHR, textStatus, errorThrown, options);\n                    }).always(function (jqXHRorResult, textStatus, jqXHRorError) {\n                        that._sending -= 1;\n                        that._onAlways(\n                            jqXHRorResult,\n                            textStatus,\n                            jqXHRorError,\n                            options\n                        );\n                        if (options.limitConcurrentUploads &&\n                                options.limitConcurrentUploads > that._sending) {\n                            // Start the next queued upload,\n                            // that has not been aborted:\n                            var nextSlot = that._slots.shift(),\n                                isPending;\n                            while (nextSlot) {\n                                // jQuery 1.6 doesn't provide .state(),\n                                // while jQuery 1.8+ removed .isRejected():\n                                isPending = nextSlot.state ?\n                                        nextSlot.state() === 'pending' :\n                                        !nextSlot.isRejected();\n                                if (isPending) {\n                                    nextSlot.resolve();\n                                    break;\n                                }\n                                nextSlot = that._slots.shift();\n                            }\n                        }\n                    });\n                    return jqXHR;\n                };\n            this._beforeSend(e, options);\n            if (this.options.sequentialUploads ||\n                    (this.options.limitConcurrentUploads &&\n                    this.options.limitConcurrentUploads <= this._sending)) {\n                if (this.options.limitConcurrentUploads > 1) {\n                    slot = $.Deferred();\n                    this._slots.push(slot);\n                    pipe = slot.pipe(send);\n                } else {\n                    pipe = (this._sequence = this._sequence.pipe(send, send));\n                }\n                // Return the piped Promise object, enhanced with an abort method,\n                // which is delegated to the jqXHR object of the current upload,\n                // and jqXHR callbacks mapped to the equivalent Promise methods:\n                pipe.abort = function () {\n                    var args = [undefined, 'abort', 'abort'];\n                    if (!jqXHR) {\n                        if (slot) {\n                            slot.rejectWith(pipe, args);\n                        }\n                        return send(false, args);\n                    }\n                    return jqXHR.abort();\n                };\n                return this._enhancePromise(pipe);\n            }\n            return send();\n        },\n\n        _onAdd: function (e, data) {\n            var that = this,\n                result = true,\n                options = $.extend({}, this.options, data),\n                limit = options.limitMultiFileUploads,\n                paramName = this._getParamName(options),\n                paramNameSet,\n                paramNameSlice,\n                fileSet,\n                i;\n            if (!(options.singleFileUploads || limit) ||\n                    !this._isXHRUpload(options)) {\n                fileSet = [data.files];\n                paramNameSet = [paramName];\n            } else if (!options.singleFileUploads && limit) {\n                fileSet = [];\n                paramNameSet = [];\n                for (i = 0; i < data.files.length; i += limit) {\n                    fileSet.push(data.files.slice(i, i + limit));\n                    paramNameSlice = paramName.slice(i, i + limit);\n                    if (!paramNameSlice.length) {\n                        paramNameSlice = paramName;\n                    }\n                    paramNameSet.push(paramNameSlice);\n                }\n            } else {\n                paramNameSet = paramName;\n            }\n            data.originalFiles = data.files;\n            $.each(fileSet || data.files, function (index, element) {\n                var newData = $.extend({}, data);\n                newData.files = fileSet ? element : [element];\n                newData.paramName = paramNameSet[index];\n                newData.submit = function () {\n                    newData.jqXHR = this.jqXHR =\n                        (that._trigger('submit', e, this) !== false) &&\n                        that._onSend(e, this);\n                    return this.jqXHR;\n                };\n                return (result = that._trigger('add', e, newData));\n            });\n            return result;\n        },\n\n        _replaceFileInput: function (input) {\n            var inputClone = input.clone(true);\n            $('<form></form>').append(inputClone)[0].reset();\n            // Detaching allows to insert the fileInput on another form\n            // without loosing the file input value:\n            input.after(inputClone).detach();\n            // Avoid memory leaks with the detached file input:\n            $.cleanData(input.unbind('remove'));\n            // Replace the original file input element in the fileInput\n            // collection with the clone, which has been copied including\n            // event handlers:\n            this.options.fileInput = this.options.fileInput.map(function (i, el) {\n                if (el === input[0]) {\n                    return inputClone[0];\n                }\n                return el;\n            });\n            // If the widget has been initialized on the file input itself,\n            // override this.element with the file input clone:\n            if (input[0] === this.element[0]) {\n                this.element = inputClone;\n            }\n        },\n\n        _handleFileTreeEntry: function (entry, path) {\n            var that = this,\n                dfd = $.Deferred(),\n                errorHandler = function () {\n                    dfd.reject();\n                },\n                dirReader;\n            path = path || '';\n            if (entry.isFile) {\n                entry.file(function (file) {\n                    file.relativePath = path;\n                    dfd.resolve(file);\n                }, errorHandler);\n            } else if (entry.isDirectory) {\n                dirReader = entry.createReader();\n                dirReader.readEntries(function (entries) {\n                    that._handleFileTreeEntries(\n                        entries,\n                        path + entry.name + '/'\n                    ).done(function (files) {\n                        dfd.resolve(files);\n                    }).fail(errorHandler);\n                }, errorHandler);\n            } else {\n                errorHandler();\n            }\n            return dfd.promise();\n        },\n\n        _handleFileTreeEntries: function (entries, path) {\n            var that = this;\n            return $.when.apply(\n                $,\n                $.map(entries, function (entry) {\n                    return that._handleFileTreeEntry(entry, path);\n                })\n            ).pipe(function () {\n                return Array.prototype.concat.apply(\n                    [],\n                    arguments\n                );\n            });\n        },\n\n        _getDroppedFiles: function (dataTransfer) {\n            dataTransfer = dataTransfer || {};\n            var items = dataTransfer.items;\n            if (items && items.length && (items[0].webkitGetAsEntry ||\n                    items[0].getAsEntry)) {\n                return this._handleFileTreeEntries(\n                    $.map(items, function (item) {\n                        if (item.webkitGetAsEntry) {\n                            return item.webkitGetAsEntry();\n                        }\n                        return item.getAsEntry();\n                    })\n                );\n            }\n            return $.Deferred().resolve(\n                $.makeArray(dataTransfer.files)\n            ).promise();\n        },\n\n        _getFileInputFiles: function (fileInput) {\n            fileInput = $(fileInput);\n            var entries = fileInput.prop('webkitEntries') ||\n                    fileInput.prop('entries'),\n                files,\n                value;\n            if (entries && entries.length) {\n                return this._handleFileTreeEntries(entries);\n            }\n            files = $.makeArray(fileInput.prop('files'));\n            if (!files.length) {\n                value = fileInput.prop('value');\n                if (!value) {\n                    return $.Deferred().reject([]).promise();\n                }\n                // If the files property is not available, the browser does not\n                // support the File API and we add a pseudo File object with\n                // the input value as name with path information removed:\n                files = [{name: value.replace(/^.*\\\\/, '')}];\n            }\n            return $.Deferred().resolve(files).promise();\n        },\n\n        _onChange: function (e) {\n            var that = e.data.fileupload,\n                data = {\n                    fileInput: $(e.target),\n                    form: $(e.target.form)\n                };\n            that._getFileInputFiles(data.fileInput).always(function (files) {\n                data.files = files;\n                if (that.options.replaceFileInput) {\n                    that._replaceFileInput(data.fileInput);\n                }\n                if (that._trigger('change', e, data) !== false) {\n                    that._onAdd(e, data);\n                }\n            });\n        },\n\n        _onPaste: function (e) {\n            var that = e.data.fileupload,\n                cbd = e.originalEvent.clipboardData,\n                items = (cbd && cbd.items) || [],\n                data = {files: []};\n            $.each(items, function (index, item) {\n                var file = item.getAsFile && item.getAsFile();\n                if (file) {\n                    data.files.push(file);\n                }\n            });\n            if (that._trigger('paste', e, data) === false ||\n                    that._onAdd(e, data) === false) {\n                return false;\n            }\n        },\n\n        _onDrop: function (e) {\n            e.preventDefault();\n            var that = e.data.fileupload,\n                dataTransfer = e.dataTransfer = e.originalEvent.dataTransfer,\n                data = {};\n            that._getDroppedFiles(dataTransfer).always(function (files) {\n                data.files = files;\n                if (that._trigger('drop', e, data) !== false) {\n                    that._onAdd(e, data);\n                }\n            });\n        },\n\n        _onDragOver: function (e) {\n            var that = e.data.fileupload,\n                dataTransfer = e.dataTransfer = e.originalEvent.dataTransfer;\n            if (that._trigger('dragover', e) === false) {\n                return false;\n            }\n            if (dataTransfer) {\n                dataTransfer.dropEffect = 'copy';\n            }\n            e.preventDefault();\n        },\n\n        _initEventHandlers: function () {\n            var ns = this.options.namespace;\n            if (this._isXHRUpload(this.options)) {\n                this.options.dropZone\n                    .bind('dragover.' + ns, {fileupload: this}, this._onDragOver)\n                    .bind('drop.' + ns, {fileupload: this}, this._onDrop)\n                    .bind('paste.' + ns, {fileupload: this}, this._onPaste);\n            }\n            this.options.fileInput\n                .bind('change.' + ns, {fileupload: this}, this._onChange);\n        },\n\n        _destroyEventHandlers: function () {\n            var ns = this.options.namespace;\n            this.options.dropZone\n                .unbind('dragover.' + ns, this._onDragOver)\n                .unbind('drop.' + ns, this._onDrop)\n                .unbind('paste.' + ns, this._onPaste);\n            this.options.fileInput\n                .unbind('change.' + ns, this._onChange);\n        },\n\n        _setOption: function (key, value) {\n            var refresh = $.inArray(key, this._refreshOptionsList) !== -1;\n            if (refresh) {\n                this._destroyEventHandlers();\n            }\n            $.Widget.prototype._setOption.call(this, key, value);\n            if (refresh) {\n                this._initSpecialOptions();\n                this._initEventHandlers();\n            }\n        },\n\n        _initSpecialOptions: function () {\n            var options = this.options;\n            if (options.fileInput === undefined) {\n                options.fileInput = this.element.is('input[type=\"file\"]') ?\n                        this.element : this.element.find('input[type=\"file\"]');\n            } else if (!(options.fileInput instanceof $)) {\n                options.fileInput = $(options.fileInput);\n            }\n            if (!(options.dropZone instanceof $)) {\n                options.dropZone = $(options.dropZone);\n            }\n        },\n\n        _create: function () {\n            var options = this.options;\n            // Initialize options set via HTML5 data-attributes:\n            $.extend(options, $(this.element[0].cloneNode(false)).data());\n            options.namespace = options.namespace || this.widgetName;\n            this._initSpecialOptions();\n            this._slots = [];\n            this._sequence = this._getXHRPromise(true);\n            this._sending = this._active = this._loaded = this._total = 0;\n            this._initEventHandlers();\n        },\n\n        destroy: function () {\n            this._destroyEventHandlers();\n            $.Widget.prototype.destroy.call(this);\n        },\n\n        enable: function () {\n            var wasDisabled = false;\n            if (this.options.disabled) {\n                wasDisabled = true;\n            }\n            $.Widget.prototype.enable.call(this);\n            if (wasDisabled) {\n                this._initEventHandlers();\n            }\n        },\n\n        disable: function () {\n            if (!this.options.disabled) {\n                this._destroyEventHandlers();\n            }\n            $.Widget.prototype.disable.call(this);\n        },\n\n        // This method is exposed to the widget API and allows adding files\n        // using the fileupload API. The data parameter accepts an object which\n        // must have a files property and can contain additional options:\n        // .fileupload('add', {files: filesList});\n        add: function (data) {\n            var that = this;\n            if (!data || this.options.disabled) {\n                return;\n            }\n            if (data.fileInput && !data.files) {\n                this._getFileInputFiles(data.fileInput).always(function (files) {\n                    data.files = files;\n                    that._onAdd(null, data);\n                });\n            } else {\n                data.files = $.makeArray(data.files);\n                this._onAdd(null, data);\n            }\n        },\n\n        // This method is exposed to the widget API and allows sending files\n        // using the fileupload API. The data parameter accepts an object which\n        // must have a files or fileInput property and can contain additional options:\n        // .fileupload('send', {files: filesList});\n        // The method returns a Promise object for the file upload call.\n        send: function (data) {\n            if (data && !this.options.disabled) {\n                if (data.fileInput && !data.files) {\n                    var that = this,\n                        dfd = $.Deferred(),\n                        promise = dfd.promise(),\n                        jqXHR,\n                        aborted;\n                    promise.abort = function () {\n                        aborted = true;\n                        if (jqXHR) {\n                            return jqXHR.abort();\n                        }\n                        dfd.reject(null, 'abort', 'abort');\n                        return promise;\n                    };\n                    this._getFileInputFiles(data.fileInput).always(\n                        function (files) {\n                            if (aborted) {\n                                return;\n                            }\n                            data.files = files;\n                            jqXHR = that._onSend(null, data).then(\n                                function (result, textStatus, jqXHR) {\n                                    dfd.resolve(result, textStatus, jqXHR);\n                                },\n                                function (jqXHR, textStatus, errorThrown) {\n                                    dfd.reject(jqXHR, textStatus, errorThrown);\n                                }\n                            );\n                        }\n                    );\n                    return this._enhancePromise(promise);\n                }\n                data.files = $.makeArray(data.files);\n                if (data.files.length) {\n                    return this._onSend(null, data);\n                }\n            }\n            return this._getXHRPromise(false, data && data.context);\n        }\n\n    });\n\n}));\n"}
}});
